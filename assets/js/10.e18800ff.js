(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{433:function(t,a,e){t.exports=e.p+"assets/img/thread-states-flow-new.848044dd.jpeg"},434:function(t,a,e){t.exports=e.p+"assets/img/thread-states-flow-runnable.71374225.jpeg"},435:function(t,a,e){t.exports=e.p+"assets/img/thread-states-flow-blocking.3b5f8d7c.jpeg"},436:function(t,a,e){t.exports=e.p+"assets/img/thread-states-flow-blocked.70a03a94.jpeg"},437:function(t,a,e){t.exports=e.p+"assets/img/thread-states-flow-waiting.1015431d.jpeg"},438:function(t,a,e){t.exports=e.p+"assets/img/thread-states-flow-timed-waiting.413742ed.jpeg"},548:function(t,a,e){"use strict";e.r(a);var i=e(5),n=Object(i.a)({},(function(){var t=this,a=t.$createElement,i=t._self._c||a;return i("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[i("p",[t._v("此为笔记，摘自徐隆曦的《Java并发编程核心》。非盈利摘抄，如确实冒犯到，请联系博主删除。")]),t._v(" "),i("h1",{attrs:{id:"线程是如何在-6-种状态之间转换的"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#线程是如何在-6-种状态之间转换的"}},[t._v("#")]),t._v(" 线程是如何在 6 种状态之间转换的？")]),t._v(" "),i("p",[t._v("本课时我们主要学习线程是如何在 6 种状态之间转换的。")]),t._v(" "),i("h2",{attrs:{id:"线程的-6-种状态"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#线程的-6-种状态"}},[t._v("#")]),t._v(" 线程的 6 种状态")]),t._v(" "),i("p",[t._v("就像生物从出生到长大、最终死亡的过程一样，线程也有自己的生命周期，在 Java 中线程的生命周期中一共有 6 种状态。")]),t._v(" "),i("ol",[i("li",[t._v("New（新创建）")]),t._v(" "),i("li",[t._v("Runnable（可运行）")]),t._v(" "),i("li",[t._v("Blocked（被阻塞）")]),t._v(" "),i("li",[t._v("Waiting（等待）")]),t._v(" "),i("li",[t._v("Timed Waiting（计时等待）")]),t._v(" "),i("li",[t._v("Terminated（被终止）")])]),t._v(" "),i("p",[t._v("如果想要确定线程当前的状态，可以通过 getState() 方法，并且线程在任何时刻只可能处于 1 种状态。")]),t._v(" "),i("h2",{attrs:{id:"new-新创建"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#new-新创建"}},[t._v("#")]),t._v(" New 新创建")]),t._v(" "),i("p",[t._v("下面我们逐个介绍线程的 6 种状态，如图所示，首先来看下左上角的 New 状态。\n"),i("img",{attrs:{src:e(433),alt:"thread-states-flow-new.jpeg"}})]),t._v(" "),i("p",[t._v("New 表示线程被创建但尚未启动的状态：当我们用 new Thread() 新建一个线程时，如果线程没有开始运行 start() 方法，所以也没有开始执行 run() 方法里面的代码，那么此时它的状态就是 New。而一旦线程调用了 start()，它的状态就会从 New 变成 Runnable，也就是状态转换图中中间的这个大方框里的内容。")]),t._v(" "),i("h2",{attrs:{id:"runnable-可运行"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#runnable-可运行"}},[t._v("#")]),t._v(" Runnable 可运行")]),t._v(" "),i("p",[i("img",{attrs:{src:e(434),alt:"thread-states-flow-runnable.jpeg"}})]),t._v(" "),i("p",[t._v("Java 中的 Runable 状态对应操作系统线程状态中的两种状态，分别是 Running 和 Ready，也就是说，Java 中处于 Runnable 状态的线程有可能正在执行，也有可能没有正在执行，正在等待被分配 CPU 资源。")]),t._v(" "),i("p",[t._v("所以，如果一个正在运行的线程是 Runnable 状态，当它运行到任务的一半时，执行该线程的 CPU 被调度去做其他事情，导致该线程暂时不运行，它的状态依然不变，还是 Runnable，因为它有可能随时被调度回来继续执行任务。")]),t._v(" "),i("h2",{attrs:{id:"阻塞状态"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#阻塞状态"}},[t._v("#")]),t._v(" 阻塞状态")]),t._v(" "),i("p",[i("img",{attrs:{src:e(435),alt:"thread-states-flow-blocking.jpeg"}})]),t._v(" "),i("p",[t._v("接下来，我们来看下 Runnable 下面的三个方框，它们统称为阻塞状态，在 Java 中阻塞状态通常不仅仅是 Blocked，实际上它包括三种状态，分别是 Blocked(被阻塞）、Waiting(等待）、Timed Waiting(计时等待），这三 种状态统称为阻塞状态，下面我们来看看这三种状态具体是什么含义。")]),t._v(" "),i("h3",{attrs:{id:"blocked-被阻塞"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#blocked-被阻塞"}},[t._v("#")]),t._v(" Blocked 被阻塞")]),t._v(" "),i("p",[i("img",{attrs:{src:e(436),alt:"thread-states-flow-blocked.jpeg"}})]),t._v(" "),i("p",[t._v("首先来看最简单的 Blocked，从箭头的流转方向可以看出，从 Runnable 状态进入 Blocked 状态只有一种可能，就是进入 synchronized 保护的代码时没有抢到 monitor 锁，无论是进入 synchronized 代码块，还是 synchronized 方法，都是一样。")]),t._v(" "),i("p",[t._v("我们再往右看，当处于 Blocked 的线程抢到 monitor 锁，就会从 Blocked 状态回到Runnable 状态。")]),t._v(" "),i("h3",{attrs:{id:"waiting-等待"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#waiting-等待"}},[t._v("#")]),t._v(" Waiting 等待")]),t._v(" "),i("p",[i("img",{attrs:{src:e(437),alt:"thread-states-flow-waiting.jpeg"}})]),t._v(" "),i("p",[t._v("我们再看看 Waiting 状态，线程进入 Waiting 状态有三种可能性。")]),t._v(" "),i("ol",[i("li",[t._v("没有设置 Timeout 参数的 Object.wait() 方法。")]),t._v(" "),i("li",[t._v("没有设置 Timeout 参数的 Thread.join() 方法。")]),t._v(" "),i("li",[t._v("LockSupport.park() 方法。")])]),t._v(" "),i("p",[t._v("刚才强调过，Blocked 仅仅针对 synchronized monitor 锁，可是在 Java 中还有很多其他的锁，比如 ReentrantLock，如果线程在获取这种锁时没有抢到该锁就会进入 Waiting 状态，因为本质上它执行了 LockSupport.park() 方法，所以会进入 Waiting 状态。同样，Object.wait() 和 Thread.join() 也会让线程进入 Waiting 状态。")]),t._v(" "),i("p",[t._v("Blocked 与 Waiting 的区别是 Blocked 在等待其他线程释放 monitor 锁，而 Waiting 则是在等待某个条件，比如 join 的线程执行完毕，或者是 notify()/notifyAll() 。")]),t._v(" "),i("h3",{attrs:{id:"timed-waiting-限期等待"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#timed-waiting-限期等待"}},[t._v("#")]),t._v(" Timed Waiting 限期等待")]),t._v(" "),i("p",[i("img",{attrs:{src:e(438),alt:"thread-states-flow-timed-waiting.jpeg"}})]),t._v(" "),i("p",[t._v("在 Waiting 上面是 Timed Waiting 状态，这两个状态是非常相似的，区别仅在于有没有时间限制，Timed Waiting 会等待超时，由系统自动唤醒，或者在超时前被唤醒信号唤醒。")]),t._v(" "),i("p",[t._v("以下情况会让线程进入 Timed Waiting 状态。")]),t._v(" "),i("ol",[i("li",[t._v("设置了时间参数的 Thread.sleep(long millis) 方法；")]),t._v(" "),i("li",[t._v("设置了时间参数的 Object.wait(long timeout) 方法；")]),t._v(" "),i("li",[t._v("设置了时间参数的 Thread.join(long millis) 方法；")]),t._v(" "),i("li",[t._v("设置了时间参数的 LockSupport.parkNanos(long nanos) 方法和 LockSupport.parkUntil(long deadline) 方法。")])]),t._v(" "),i("p",[t._v("讲完如何进入这三种阻塞状态，我们再来看下如何从这三种状态流转到下一个状态。")]),t._v(" "),i("p",[t._v("想要从 Blocked 状态进入 Runnable 状态，要求线程获取 monitor 锁，而从 Waiting 状态流转到其他状态则比较特殊，因为首先 Waiting 是不限时的，也就是说无论过了多长时间它都不会主动恢复。")]),t._v(" "),i("p",[t._v("只有当执行了 LockSupport.unpark()，或者 join 的线程运行结束，或者被中断时才可以进入 Runnable 状态。")]),t._v(" "),i("p",[t._v("如果其他线程调用 notify() 或 notifyAll()来唤醒它，它会直接进入 Blocked 状态，这是为什么呢？因为唤醒 Waiting 线程的线程如果调用 notify() 或 notifyAll()，要求必须首先持有该 monitor 锁，所以处于 Waiting 状态的线程被唤醒时拿不到该锁，就会进入 Blocked 状态，直到执行了 notify()/notifyAll() 的唤醒它的线程执行完毕并释放 monitor 锁，才可能轮到它去抢夺这把锁，如果它能抢到，就会从 Blocked 状态回到 Runnable 状态。")]),t._v(" "),i("p",[t._v("同样在 Timed Waiting 中执行 notify() 和 notifyAll() 也是一样的道理，它们会先进入 Blocked 状态，然后抢夺锁成功后，再回到 Runnable 状态。")]),t._v(" "),i("p",[t._v("当然对于 Timed Waiting 而言，如果它的超时时间到了且能直接获取到锁/join的线程运行结束/被中断/调用了LockSupport.unpark()，会直接恢复到 Runnable 状态，而无需经历 Blocked 状态。")]),t._v(" "),i("h2",{attrs:{id:"terminated-终止"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#terminated-终止"}},[t._v("#")]),t._v(" Terminated 终止")]),t._v(" "),i("p",[t._v("再来看看最后一种状态，Terminated 终止状态，要想进入这个状态有两种可能。")]),t._v(" "),i("p",[t._v("run() 方法执行完毕，线程正常退出。\n出现一个没有捕获的异常，终止了 run() 方法，最终导致意外终止。\n注意点\n最后我们再看线程转换的两个注意点。")]),t._v(" "),i("ol",[i("li",[t._v("线程的状态是需要按照箭头方向来走的，比如线程从 New 状态是不可以直接进入 Blocked 状态的，它需要先经历 Runnable 状态。")]),t._v(" "),i("li",[t._v("线程生命周期不可逆：一旦进入 Runnable 状态就不能回到 New 状态；一旦被终止就不可能再有任何状态的变化。所以一个线程只能有一次 New 和 Terminated 状态，只有处于中间状态才可以相互转换。\n好了，本课时的内容就全部讲完了，下一课时我将讲解“wait()/notify()/notifyAll() 的使用注意事项”记得按时来听课啊，下一课时见。")])])])}),[],!1,null,null,null);a.default=n.exports}}]);